import java.util.ArrayList;
import java.util.Comparator;
import java.util.Scanner;

public class BandwidthManager {

    public class Packet {

        private int priority;
        private int enterAsIndex;
        private String content;

        public Packet(int priority) {
            this.setPriority(priority);
        }

        public int getPriority() {
            return priority;
        }

        public void setPriority(int priority) {
            this.priority = priority;
        }

        public String getContent() {
            return content;
        }

        public void setContent(String content) {
            this.content = content;
        }

        public int getEnterAsIndex() {
            return enterAsIndex;
        }

        public void setEnterAsIndex(int enterAsIndex) {
            this.enterAsIndex = enterAsIndex;
        }
    }

    private final String EMPTY_QUEUE = "Nothing to send!";

    private PriorityQueue<Packet> pq;

    public BandwidthManager() {
        this.pq = new PriorityQueue<Packet>(new Comparator<Packet>() {

            @Override
            public int compare(Packet o1, Packet o2) {
                return Integer.compare(o1.priority, o2.priority);
            }

        });
    }

    // receives a packet with specified protocol and payload
    public void rcv(String protocol, String payload) {
        Packet p = null;

        switch (protocol) {
            case "ICMP":
                p = new Packet(6);
                break;
            case "UDP":
                p = new Packet(5);
                break;
            case "RTM":
                p = new Packet(4);
                break;
            case "IGMP":
                p = new Packet(3);
                break;
            case "DNS":
                p = new Packet(2);
                break;
            case "TCP":
                p = new Packet(1);
                break;

            default:
                throw new IllegalArgumentException("Invalid protocol");
        }

        p.setContent(payload);
        p.setEnterAsIndex(this.pq.arr.size());

        this.pq.push(p);
    }

    public static void main(String[] args) {

        BandwidthManager m = new BandwidthManager();

        Scanner s = new Scanner(System.in);
        int n = s.nextInt();

        for (int i = 0; i < n; i++) {
            String command = s.next();

            switch (command) {
                case "rcv":
                    m.rcv(s.next(), s.next());
                    break;

                default:
                    m.send();
                    break;
            }
        }
    }

    // returns the payload of the packet which should be sent
    public void send() {
        Packet recievedPacket = this.pq.pop();
        String outputMessage = "";

        if (recievedPacket == null) {
            outputMessage = this.EMPTY_QUEUE;
        } else {
            outputMessage = recievedPacket.getContent();
        }

        System.out.println(outputMessage);
    }

    public class PriorityQueue<Packet> {

        private ArrayList<Packet> arr;
        private Comparator<Packet> comparator;

        public PriorityQueue(Comparator<Packet> comparator) {
            this.comparator = comparator;
            this.arr = new ArrayList<Packet>();
        }

        public void push(Packet value) {
            this.arr.add(value);
            this.siftUp(this.arr.size() - 1);
        }

        public Packet pop() {
            if (this.arr.size() == 0) {
                return null;
            }

            Packet head = this.peek();

            swap(0, this.arr.size() - 1);
            this.arr.remove(this.arr.size() - 1);
            this.siftDown(0, this.arr.size());

            return head;
        }

        public Packet peek() {
            if (this.arr.size() == 0) {
                return null;
            }

            return this.arr.get(0);
        }

        private void swap(int i, int j) {
            Packet temp = this.arr.get(i);
            this.arr.set(i, this.arr.get(j));
            this.arr.set(j, temp);
        }

        public void heapify() {

            for (int i = this.getSize() / 2 - 1; i >= 0; i--) {
                this.siftDown(i, this.arr.size());
            }
        }

        private void siftUp(int index) {

            while (index > 0) {
                Packet currentParent = this.arr.get((index - 1) / 2);

                if (this.comparator.compare(this.arr.get(index), currentParent) > 0) {
                    swap(index, (index - 1) / 2);
                    siftUp((index - 1) / 2);
                } else {
                    break;
                }
            }
        }

        private void siftDown(int index, int size) {

            while (index <= size / 2 - 1) {
                Packet currentParent = this.arr.get(index);

                int leftChildIndex = 2 * index + 1;
                leftChildIndex = leftChildIndex >= size ? -1 : leftChildIndex;

                int rightChildIndex = 2 * index + 2;
                rightChildIndex = rightChildIndex >= size ? -1 : rightChildIndex;

                int maxChildIndex = index;

                if (leftChildIndex != -1 && rightChildIndex != -1) {

                    if (this.comparator.compare(this.arr.get(leftChildIndex), this.arr.get(rightChildIndex)) == 0) {
                        maxChildIndex = Integer.compare((BandwidthManager.Packet) this.arr.get(leftChildIndex)).getEnterAsIndex(), (BandwidthManager.Packet) this.arr.get(leftChildIndex)).getEnterAsIndex() == 0) {
                            
                        }
                    } else {
                        maxChildIndex = this.comparator.compare(this.arr.get(leftChildIndex),
                                this.arr.get(rightChildIndex)) > 0 ? leftChildIndex : rightChildIndex;
                    }
                } else if (leftChildIndex != -1) {
                    maxChildIndex = leftChildIndex;
                } else if (rightChildIndex != -1) {
                    maxChildIndex = rightChildIndex;
                }

                if (this.comparator.compare(this.arr.get(maxChildIndex), currentParent) >= 0) {
                    swap(index, maxChildIndex);
                    siftDown(maxChildIndex, size);
                } else {
                    break;
                }
            }
        }

        public int getSize() {
            return this.arr.size();
        }
    }

}