package textCompression;

import java.io.IOException;
import java.nio.file.Path;
import java.util.LinkedHashMap;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import readAndWriteUtils.FileUtils;

public class Utils {

    public static void compressFile(Path source, Path destination) throws IOException {
        if (!destination.toFile().exists()) {
            FileUtils.getInstance().writeTo(destination.toFile(), "");
        }

        Pattern p = Pattern.compile("\\w+");
        String sourceContent = FileUtils.getInstance().readFrom(source.toFile());

        // Contains all the words stored in word:index pair for easier search
        LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>();
        int wordIndex = 0;
        int symbolLetter = 0;

        Matcher words = p.matcher(sourceContent);
        // Storing all of the spaces or .,? etc symbols
        String[] betweenWords = sourceContent.split("\\w+");
        StringBuilder destContent = new StringBuilder();

        while (words.find()) {
            String currentWord = sourceContent.substring(words.start(), words.end());
            System.out.println(currentWord);

            if (!map.containsValue(currentWord)) {
                map.put(currentWord, wordIndex);
                destContent.append("~" + (wordIndex++));
            } else {
                destContent.append("~" + map.get(currentWord));
            }

            // Add the symbol after the word
            destContent.append(betweenWords[symbolLetter++]);
        }

        // Delimiter delegates the start of the hash map
        destContent.append("|");

        // Add the hash map legend after the compressed test
        for (Entry<String, Integer> entry : map.entrySet()) {
            destContent.append(entry.getKey() + ",");
        }

        FileUtils.getInstance().writeTo(destination, destContent.toString().substring(0, destContent.length() - 1));
    }

    public static void decompressFile(Path source, Path destination) {

    }
}
