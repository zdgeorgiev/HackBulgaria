package calculator;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Stack;

public class Calculator {
    private String expression;
    private Stack<String> expressionAsStack;

    private Map<Character, Integer> operators;

    public Calculator() {
        // operators represented as <Operator, Priority>
        this.operators = new HashMap<Character, Integer>();
        this.expressionAsStack = new Stack<String>();

        operators.put('!', 3);
        operators.put('^', 3);
        operators.put('*', 2);
        operators.put('/', 2);
        operators.put('+', 1);
        operators.put('-', 1);
        operators.put('(', 0);
        operators.put(')', 0);
    }

    public float calc() {
        float result = 0.0f;
        Queue<Character> cpy = new PriorityQueue<Character>();

        for (int i = 0; i < this.expression.length(); i++) {
            char token = this.expression.charAt(i);

            if (token >= '0' && token <= '9') {
                cpy.offer(token);
            } else {
                switch (token) {
                    case '^':
                    case '!':

                        break;
                    // Left associativity
                    default:
                        float rightNumber = cpy.poll();
                        float leftNumber = cpy.poll();
                        break;
                }
            }
        }

        return result;
    }
    
    private String convertToRPN(String expression) {
        StringBuilder rpn = new StringBuilder();
        Stack<Character> tempOperators = new Stack<Character>();

        for (int i = 0; i < expression.length(); i++) {
            Character token = expression.charAt(i);

            if (token >= '0' && token <= '9') {
                rpn.append(token);
            } else {
                switch (token) {
                // Operators with right associativity
                    case '^':
                    case '!':
                        while (!tempOperators.isEmpty()) {
                            if (this.operators.get(token) < this.operators.get(tempOperators.peek())) {
                                rpn.append(tempOperators.pop());
                                // ----
                                this.expressionAsStack.push(tempOperators.pop().toString());
                            } else {
                                break;
                            }
                        }

                        tempOperators.push(token);
                        // ---------
                        this.expressionAsStack.push(token.toString());
                        break;

                    case '(':
                        tempOperators.push(token);
                        // -------
                        this.expressionAsStack.push(token.toString());
                        break;

                    case ')':
                        while (true) {
                            if (tempOperators.peek() == '(') {
                                tempOperators.pop();
                                break;
                            }

                            rpn.append(tempOperators.pop());
                            // ------
                            this.expressionAsStack.push(tempOperators.pop().toString());
                        }

                        break;

                    // Operators with left associativity ( +, -, *, / )
                    default:
                        while (!tempOperators.isEmpty()) {
                            if (this.operators.get(token) <= this.operators.get(tempOperators.peek())) {
                                rpn.append(tempOperators.pop());
                                // -------
                                this.expressionAsStack.push(tempOperators.pop().toString());
                            } else {
                                break;
                            }
                        }

                        tempOperators.push(token);
                        // -------
                        this.expressionAsStack.push(token.toString());
                        break;
                }
            }
        }

        while (!tempOperators.isEmpty()) {
            rpn.append(tempOperators.pop());
            // -------
            this.expressionAsStack.push(tempOperators.pop().toString());
        }

        return rpn.toString();
    }

    public String getExpression() {
        return this.expression;
    }

    public void setExpression(String expression) {
        this.expression = this.convertToRPN(expression);
    }
}